name: Build, Test, Push, and Deploy (Production Ready)

# K√≠ch ho·∫°t workflow khi c√≥ push l√™n nh√°nh 'main'
on:
  push:
    branches:
      - main 

env:
  # T√™n t√†i nguy√™n Terraform c·ªßa b·∫°n
  ACR_NAME: "acruitgoprod"
  AKS_CLUSTER_NAME: "aks-uitgo-prod"
  RESOURCE_GROUP_NAME: "rg-uitgo-prod"
  COSMOS_DB_NAME: "cosmos-uitgo-prod"
  POSTGRES_SERVER_NAME: "psql-uitgo-prod"
  REDIS_CACHE_NAME: "redis-uitgo-prod"

jobs:
  # ----------------------------------------------
  #  GIAI ƒêO·∫†N 1: TEST (Unit Test)
  # ----------------------------------------------
  test:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'

    - name: Install test dependencies
      run: |
        python -m pip install --upgrade pip
        # C√†i ƒë·∫∑t c√°c th∆∞ vi·ªán c·∫ßn thi·∫øt cho Unit Test
        pip install -r tests/requirements.txt
        # C√†i th√™m c√°c th∆∞ vi·ªán m√† code c·ªßa b·∫°n d√πng (n·∫øu test c·∫ßn)
        pip install fastapi uvicorn pydantic python-dotenv "passlib[bcrypt]"

    - name: Run unit tests
      run: |
        # Gi·∫£ s·ª≠ c√°c file test c·ªßa b·∫°n n·∫±m trong th∆∞ m·ª•c tests/
        # B·ªè qua file smoke_test.py (v√¨ ƒë√¢y l√† integration test)
        pytest tests/ --deselect tests/smoke_test.py
      continue-on-error: false # D·ª´ng l·∫°i n·∫øu test fail

  # ----------------------------------------------
  #  PHASE 3: SECURITY SCANNING (DevSecOps)
  # ----------------------------------------------
  
  # NEW JOB 1: SAST (Static Application Security Testing)
  sast:
    runs-on: ubuntu-latest
    needs: test
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Bandit
      run: pip install bandit[toml]
    
    - name: Run Bandit SAST
      run: |
        echo "üîç Running SAST scan on all Python services..."
        bandit -r UserService/ TripService/ DriverService/ LocationService/ PaymentService/ \
          -f json -o bandit-report.json || true
        echo ""
        echo "üìä High severity issues:"
        bandit -r UserService/ TripService/ DriverService/ LocationService/ PaymentService/ -ll
      continue-on-error: false
    
    - name: Upload SAST results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: bandit-sast-report
        path: bandit-report.json

  # NEW JOB 2: Dependency Scanning
  dependency-scan:
    runs-on: ubuntu-latest
    needs: test
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Safety
      run: pip install safety
    
    - name: Scan dependencies for vulnerabilities
      run: |
        echo "üîç Scanning dependencies for known vulnerabilities..."
        for service in UserService TripService DriverService LocationService PaymentService; do
          echo ""
          echo "üì¶ Scanning $service..."
          safety check -r $service/requirements.txt --json --output ${service}-safety.json || true
          safety check -r $service/requirements.txt || true
        done
      continue-on-error: false
    
    - name: Upload dependency scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: safety-dependency-reports
        path: '*-safety.json'

  # NEW JOB 3: Secrets Scanning
  secrets-scan:
    runs-on: ubuntu-latest
    needs: test
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
      with:
        fetch-depth: 0  # Full history for TruffleHog
    
    - name: Run TruffleHog secrets scanner
      run: |
        echo "üîç Scanning for exposed secrets in git history..."
        # Use --only-verified to ignore false positives (like docs/ examples)
        docker run --rm -v "$PWD:/pwd" trufflesecurity/trufflehog:latest \
          filesystem /pwd --json --fail --only-verified > trufflehog-report.json || true
        
        # Check if verified secrets found
        if [ -s trufflehog-report.json ]; then
          echo "‚ùå VERIFIED SECRETS DETECTED! Check trufflehog-report.json"
          cat trufflehog-report.json
          exit 1
        else
          echo "‚úÖ No verified secrets detected"
        fi
      continue-on-error: false
    
    - name: Upload secrets scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: trufflehog-secrets-report
        path: trufflehog-report.json

  # NEW JOB 4: IaC (Infrastructure as Code) Scanning  
  iac-scan:
    runs-on: ubuntu-latest
    needs: test
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.11'
    
    - name: Install Checkov
      run: pip install checkov
    
    - name: Scan Terraform files
      run: |
        echo "üîç Scanning Terraform configs for security issues..."
        checkov -d terraform/ \
          --framework terraform \
          --output json \
          --output-file checkov-terraform-report.json \
          --soft-fail || true
        
        echo ""
        echo "üìä Terraform scan summary:"
        checkov -d terraform/ --framework terraform --compact || true
      continue-on-error: false
    
    - name: Scan Kubernetes manifests
      run: |
        echo ""
        echo "üîç Scanning Kubernetes manifests..."
        checkov -d k8s/ \
          --framework kubernetes \
          --output json \
          --output-file checkov-k8s-report.json \
          --soft-fail || true
        
        echo ""
        echo "üìä Kubernetes scan summary:"
        checkov -d k8s/ --framework kubernetes --compact || true
      continue-on-error: false
    
    - name: Upload IaC scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: checkov-iac-reports
        path: checkov-*.json

  # ----------------------------------------------
  #  GIAI ƒêO·∫†N 2: BUILD (CI) - Now depends on security scans
  # ----------------------------------------------
  build:
    runs-on: ubuntu-latest
    needs: [test, sast, dependency-scan, secrets-scan, iac-scan] # Wait for all security scans
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    # --- S·ª¨A L·ªñI ƒêƒÇNG NH·∫¨P ACR ---
    - name: Log in to ACR (D√πng az acr login)
      run: |
        az acr login --name ${{ env.ACR_NAME }}
        
    - name: Build and push (LocationService)
      run: |
        docker build ./LocationService -t ${{ env.ACR_NAME }}.azurecr.io/locationservice:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/locationservice:${{ github.sha }}

    - name: Build and push (TripService)
      run: |
        docker build ./TripService -t ${{ env.ACR_NAME }}.azurecr.io/tripservice:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/tripservice:${{ github.sha }}

    - name: Build and push (DriverService)
      run: |
        docker build ./DriverService -t ${{ env.ACR_NAME }}.azurecr.io/driverservice:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/driverservice:${{ github.sha }}

    - name: Build and push (PaymentService)
      run: |
        docker build ./PaymentService -t ${{ env.ACR_NAME }}.azurecr.io/paymentservice:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/paymentservice:${{ github.sha }}

    - name: Build and push (UserService)
      run: |
        docker build ./UserService -t ${{ env.ACR_NAME }}.azurecr.io/userservice:${{ github.sha }}
        docker push ${{ env.ACR_NAME }}.azurecr.io/userservice:${{ github.sha }}
    
    # NEW: Container Security Scanning with Trivy
    - name: Scan all container images with Trivy
      run: |
        echo "üîç Scanning container images for vulnerabilities..."
        
        # Install Trivy
        wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
        echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
        sudo apt-get update
        sudo apt-get install trivy -y
        
        # Scan all service images
        for service in locationservice tripservice driverservice paymentservice userservice; do
          echo ""
          echo "üì¶ Scanning $service..."
          trivy image \
            --severity HIGH,CRITICAL \
            --exit-code 0 \
            --format json \
            --output trivy-${service}.json \
            ${{ env.ACR_NAME }}.azurecr.io/${service}:${{ github.sha }} || true
          
          # Show summary
          trivy image \
            --severity HIGH,CRITICAL \
            ${{ env.ACR_NAME }}.azurecr.io/${service}:${{ github.sha }}
        done
        
        echo ""
        echo "‚úÖ Container scanning complete"
      continue-on-error: false
    
    - name: Upload Trivy scan results
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: trivy-container-reports
        path: trivy-*.json

  # ----------------------------------------------
  #  GIAI ƒêO·∫†N 3: DEPLOY (CD)
  # ----------------------------------------------
  deploy:
    runs-on: ubuntu-latest
    needs: build # Ph·∫£i ch·ªù 'build' xong
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}

    - name: Set AKS context (K·∫øt n·ªëi kubectl)
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.RESOURCE_GROUP_NAME }}
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}

    # --- L·∫§Y CHU·ªñI K·∫æT N·ªêI T·ª™ AZURE ---
    - name: Get Azure Service Connection Strings
      id: azure-keys # ƒê·∫∑t ID ƒë·ªÉ c√°c b∆∞·ªõc sau g·ªçi
      run: |
        # L·∫•y Connection String c·ªßa CosmosDB (Mongo)
        COSMOS_CS=$(az cosmosdb keys list --name ${{ env.COSMOS_DB_NAME }} --resource-group ${{ env.RESOURCE_GROUP_NAME }} --type connection-strings --query "connectionStrings[0].connectionString" -o tsv)
        
        # L·∫•y Host v√† Key c·ªßa Redis
        REDIS_HOST=$(az redis show --name ${{ env.REDIS_CACHE_NAME }} --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query "hostName" -o tsv)
        REDIS_KEY=$(az redis list-keys --name ${{ env.REDIS_CACHE_NAME }} --resource-group ${{ env.RESOURCE_GROUP_NAME }} --query "primaryKey" -o tsv)
        
        # L·∫•y th√¥ng tin Postgres (Host v√† User l√† c·ªë ƒë·ªãnh)
        POSTGRES_HOST="${{ env.POSTGRES_SERVER_NAME }}.postgres.database.azure.com"
        POSTGRES_USER="postgresadmin"

        # ƒê·∫∑t c√°c gi√° tr·ªã n√†y l√†m output (S·ª¨ D·ª§NG C√ö PH√ÅP M·ªöI)
        echo "COSMOS_CONNECTION_STRING=$COSMOS_CS" >> $GITHUB_OUTPUT
        echo "REDIS_HOST=$REDIS_HOST" >> $GITHUB_OUTPUT
        echo "REDIS_KEY=$REDIS_KEY" >> $GITHUB_OUTPUT
        echo "POSTGRES_HOST=$POSTGRES_HOST" >> $GITHUB_OUTPUT
        echo "POSTGRES_USER=$POSTGRES_USER" >> $GITHUB_OUTPUT

    # --- T·∫†O K8S SECRETS ---
    - name: Create K8s Secrets
      env:
        # L·∫•y output t·ª´ b∆∞·ªõc 'azure-keys'
        DB_PASSWORD: ${{ secrets.DB_PASSWORD }} # L·∫•y t·ª´ GitHub Secret
        COSMOS_CONNECTION_STRING: ${{ steps.azure-keys.outputs.COSMOS_CONNECTION_STRING }}
        REDIS_HOST: ${{ steps.azure-keys.outputs.REDIS_HOST }}
        REDIS_KEY: ${{ steps.azure-keys.outputs.REDIS_KEY }}
        POSTGRES_HOST: ${{ steps.azure-keys.outputs.POSTGRES_HOST }}
        POSTGRES_USER: ${{ steps.azure-keys.outputs.POSTGRES_USER }}
        
        # L·∫•y c√°c secret kh√°c t·ª´ GitHub Secrets
        JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}
        MAPBOX_ACCESS_TOKEN: ${{ secrets.MAPBOX_ACCESS_TOKEN }}
        TRIPSVC_CLIENT_ID: ${{ secrets.TRIPSVC_CLIENT_ID }}
        TRIPSVC_CLIENT_SECRET: ${{ secrets.TRIPSVC_CLIENT_SECRET }}
        USER_SERVICE_BASE_URL: ${{ secrets.USER_SERVICE_BASE_URL }}
        VNP_TMN_CODE: ${{ secrets.VNP_TMN_CODE }}
        VNP_HASH_SECRET: ${{ secrets.VNP_HASH_SECRET }}
        VNP_URL: ${{ secrets.VNP_URL }}
      run: |
        kubectl create secret generic uitgo-secrets --dry-run=client -o yaml \
          --from-literal=DB_PASSWORD=$DB_PASSWORD \
          --from-literal=COSMOS_CONNECTION_STRING=$COSMOS_CONNECTION_STRING \
          --from-literal=REDIS_HOST=$REDIS_HOST \
          --from-literal=REDIS_KEY=$REDIS_KEY \
          --from-literal=POSTGRES_HOST=$POSTGRES_HOST \
          --from-literal=POSTGRES_USER=$POSTGRES_USER \
          --from-literal=JWT_SECRET_KEY=$JWT_SECRET_KEY \
          --from-literal=MAPBOX_ACCESS_TOKEN=$MAPBOX_ACCESS_TOKEN \
          --from-literal=TRIPSVC_CLIENT_ID=$TRIPSVC_CLIENT_ID \
          --from-literal=TRIPSVC_CLIENT_SECRET=$TRIPSVC_CLIENT_SECRET \
          --from-literal=USER_SERVICE_BASE_URL=$USER_SERVICE_BASE_URL \
          --from-literal=VNP_TMN_CODE=$VNP_TMN_CODE \
          --from-literal=VNP_HASH_SECRET=$VNP_HASH_SECRET \
          --from-literal=VNP_URL=$VNP_URL \
        | kubectl apply -f -

    # --- C·∫¨P NH·∫¨T TAG IMAGE M·ªöI ---
    - name: Update K8s manifests with new image tag
      run: |
        sed -i 's|image: ${{ env.ACR_NAME }}.azurecr.io/locationservice:.*|image: ${{ env.ACR_NAME }}.azurecr.io/locationservice:${{ github.sha }}|g' k8s/locationservice.yaml
        sed -i 's|image: ${{ env.ACR_NAME }}.azurecr.io/tripservice:.*|image: ${{ env.ACR_NAME }}.azurecr.io/tripservice:${{ github.sha }}|g' k8s/tripservice.yaml
        sed -i 's|image: ${{ env.ACR_NAME }}.azurecr.io/driverservice:.*|image: ${{ env.ACR_NAME }}.azurecr.io/driverservice:${{ github.sha }}|g' k8s/driverservice.yaml
        sed -i 's|image: ${{ env.ACR_NAME }}.azurecr.io/paymentservice:.*|image: ${{ env.ACR_NAME }}.azurecr.io/paymentservice:${{ github.sha }}|g' k8s/paymentservice.yaml
        sed -i 's|image: ${{ env.ACR_NAME }}.azurecr.io/userservice:.*|image: ${{ env.ACR_NAME }}.azurecr.io/userservice:${{ github.sha }}|g' k8s/userservice.yaml

    # --- DEPLOY NGINX INGRESS CONTROLLER ---
    - name: Deploy NGINX Ingress Controller
      run: |
        kubectl apply -f k8s/nginx-ingress-controller.yaml
        # Ch·ªù ingress controller ready (tƒÉng timeout l√™n 10 ph√∫t)
        kubectl wait --namespace ingress-nginx \
          --for=condition=ready pod \
          --selector=app.kubernetes.io/component=controller \
          --timeout=600s || echo "Ingress controller ch∆∞a ready, nh∆∞ng ti·∫øp t·ª•c deploy..."

    # --- DEPLOY 7 FILE .YAML C·ª¶A ·ª®NG D·ª§NG  ---
    - name: Deploy all K8s manifests
      run: |
        # Ch·ªâ √°p d·ª•ng 5 file service, b·ªè qua c√°c file r√°c
        kubectl apply -f k8s/locationservice.yaml
        kubectl apply -f k8s/tripservice.yaml
        kubectl apply -f k8s/driverservice.yaml
        kubectl apply -f k8s/paymentservice.yaml
        kubectl apply -f k8s/userservice.yaml
        kubectl apply -f k8s/ingress.yaml
        kubectl apply -f k8s/ingress-websocket.yaml

  # ----------------------------------------------
  #  GIAI ƒêO·∫†N 4: SMOKE TEST
  # ----------------------------------------------
  smoke_test:
    runs-on: ubuntu-latest
    needs: deploy # Ph·∫£i ch·ªù 'deploy' xong
    steps:
    - name: Checkout code
      uses: actions/checkout@v3

    - name: Log in to Azure
      uses: azure/login@v1
      with:
        creds: ${{ secrets.AZURE_CREDENTIALS }}
    
    - name: Set AKS context
      uses: azure/aks-set-context@v3
      with:
        resource-group: ${{ env.RESOURCE_GROUP_NAME }}
        cluster-name: ${{ env.AKS_CLUSTER_NAME }}
        
    # --- S·ª¨A L·ªñI TIMEOUT ---
    - name: Get Ingress Load Balancer IP (Ch·ªù t·ªëi ƒëa 5 ph√∫t)
      id: lb-ip
      run: |
        echo "Waiting for Ingress Load Balancer IP..."
        start_time=$(date +%s)
        while true; do
          IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

          # Ki·ªÉm tra xem IP ƒë√£ c√≥ gi√° tr·ªã ch∆∞a (kh√¥ng r·ªóng v√† kh√¥ng ph·∫£i <none>)
          if [ -n "$IP" ] && [ "$IP" != "<none>" ]; then
            echo "Ingress Load Balancer IP: $IP"
            echo "API_URL=http://$IP" >> $GITHUB_OUTPUT
            break
          fi

          current_time=$(date +%s)
          elapsed=$((current_time - start_time))

          if [ $elapsed -gt 300 ]; then # 5 ph√∫t timeout
            echo "::error::Timeout: Kh√¥ng th·ªÉ l·∫•y IP c·ªßa Ingress Load Balancer sau 5 ph√∫t."
            exit 1
          fi

          echo "IP still <pending>, waiting 15 seconds..."
          sleep 15
        done
        
    - name: Install test dependencies
      run: |
        pip install -r tests/requirements.txt
        
    - name: Run smoke tests
      env:
        # "B∆°m" IP public v·ª´a l·∫•y ƒë∆∞·ª£c v√†o file smoke test
        API_URL: ${{ steps.lb-ip.outputs.API_URL }}
      run: |
        python tests/smoke_test.py

  # ----------------------------------------------
  #  PHASE 3: DAST (Dynamic Application Security Testing)
  # ----------------------------------------------
  dast:
    runs-on: ubuntu-latest
    needs: smoke_test
    steps:
    - name: Checkout code
      uses: actions/checkout@v3
    
    - name: Get Ingress IP
      run: |
        echo "Getting Ingress LoadBalancer IP for DAST scan..."

        # Check if AZURE_CREDENTIALS is available and valid
        if [ -n "${{ secrets.AZURE_CREDENTIALS }}" ]; then
          echo "Authenticating to Azure..."
          echo "${{ secrets.AZURE_CREDENTIALS }}" > azure_creds.txt

          # Try to detect if it's JSON or YAML format by testing with jq directly
          if echo "${{ secrets.AZURE_CREDENTIALS }}" | jq empty 2>/dev/null; then
            echo "Detected JSON format for Azure credentials"
            echo "${{ secrets.AZURE_CREDENTIALS }}" > azure_creds.json

            # Extract credentials from JSON
            CLIENT_ID=$(jq -r '.clientId // .appId // empty' azure_creds.json)
            CLIENT_SECRET=$(jq -r '.clientSecret // .password // empty' azure_creds.json)
            TENANT_ID=$(jq -r '.tenantId // .tenant // empty' azure_creds.json)
          else
            echo "Detected YAML format for Azure credentials, parsing directly..."

            # Extract credentials directly from YAML using grep and sed
            CLIENT_ID=$(echo "${{ secrets.AZURE_CREDENTIALS }}" | grep -E '^\s*clientId:' | sed 's/.*clientId:\s*//' | tr -d ', ')
            CLIENT_SECRET=$(echo "${{ secrets.AZURE_CREDENTIALS }}" | grep -E '^\s*clientSecret:' | sed 's/.*clientSecret:\s*//' | tr -d ', ')
            TENANT_ID=$(echo "${{ secrets.AZURE_CREDENTIALS }}" | grep -E '^\s*tenantId:' | sed 's/.*tenantId:\s*//' | tr -d ', ')

            # Also try alternative field names
            if [ -z "$CLIENT_ID" ]; then
              CLIENT_ID=$(echo "${{ secrets.AZURE_CREDENTIALS }}" | grep -E '^\s*appId:' | sed 's/.*appId:\s*//' | tr -d ', ')
            fi
            if [ -z "$CLIENT_SECRET" ]; then
              CLIENT_SECRET=$(echo "${{ secrets.AZURE_CREDENTIALS }}" | grep -E '^\s*password:' | sed 's/.*password:\s*//' | tr -d ', ')
            fi
            if [ -z "$TENANT_ID" ]; then
              TENANT_ID=$(echo "${{ secrets.AZURE_CREDENTIALS }}" | grep -E '^\s*tenant:' | sed 's/.*tenant:\s*//' | tr -d ', ')
            fi
          fi

          # Check if all credentials are available
          if [ -z "$CLIENT_ID" ] || [ -z "$CLIENT_SECRET" ] || [ -z "$TENANT_ID" ]; then
            echo "‚ùå Error: Missing Azure credentials"
            echo "CLIENT_ID found: ${CLIENT_ID:+YES}"
            echo "CLIENT_SECRET found: ${CLIENT_SECRET:+YES}"
            echo "TENANT_ID found: ${TENANT_ID:+YES}"
            echo "Raw credential format (first 200 chars):"
            echo "${{ secrets.AZURE_CREDENTIALS }}" | head -c 200
            echo ""
            exit 1
          fi

          echo "‚úÖ Credentials extracted successfully"
          echo "CLIENT_ID: ${CLIENT_ID:0:10}..."
          echo "TENANT_ID: ${TENANT_ID:0:10}..."

          # Authenticate to Azure
          az login --service-principal -u "$CLIENT_ID" -p "$CLIENT_SECRET" --tenant "$TENANT_ID"

          # Set AKS context
          az aks get-credentials --resource-group ${{ env.RESOURCE_GROUP_NAME }} --name ${{ env.AKS_CLUSTER_NAME }} --overwrite-existing
        else
          echo "‚ö†Ô∏è AZURE_CREDENTIALS not found, trying to use existing kubeconfig..."
        fi

        # Get Ingress IP
        echo "Getting Ingress service IP..."
        INGRESS_IP=$(kubectl get service ingress-nginx-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")

        if [ -z "$INGRESS_IP" ]; then
          echo "‚ùå Error: Could not get Ingress IP"
          echo "Available services:"
          kubectl get svc -A
          exit 1
        fi

        echo "TARGET_URL=http://$INGRESS_IP" >> $GITHUB_ENV
        echo "‚úÖ Targeting: http://$INGRESS_IP"
    
    - name: Run OWASP ZAP Baseline Scan
      run: |
        echo "üîç Running OWASP ZAP DAST scan on deployed application..."

        # Check if TARGET_URL is set
        if [ -z "${{ env.TARGET_URL }}" ]; then
          echo "‚ùå Error: TARGET_URL is not set"
          echo "Skipping DAST scan..."
          exit 0
        fi

        echo "Scanning target: ${{ env.TARGET_URL }}"

        # Test if target is reachable before scanning
        echo "Testing target reachability..."
        if curl_response=$(curl -s -w "%{http_code}" --connect-timeout 10 --max-time 30 "${{ env.TARGET_URL }}" 2>/dev/null); then
          http_code="${curl_response: -3}"
          response_body="${curl_response%???}"
          echo "‚úÖ Target is reachable - HTTP $http_code"
          if [ -n "$response_body" ]; then
            echo "Response preview: ${response_body:0:100}..."
          fi
        else
          echo "‚ö†Ô∏è Warning: Target URL is not reachable, but proceeding with scan anyway..."
          echo "Debugging connection:"
          curl -v --connect-timeout 5 --max-time 10 "${{ env.TARGET_URL }}" || echo "Connection failed completely"
        fi

        # Run OWASP ZAP scan with better error handling and debugging
        echo "Starting ZAP scan with command:"
        echo "docker run --rm -v \$(pwd):/zap/wrk/:rw owasp/zap2docker-stable zap-baseline.py -t \"${{ env.TARGET_URL }}\" -r zap-baseline-report.html -J zap-baseline-report.json -w zap-baseline-report.md --no_fail_on_warn"

        docker run --rm \
          -v $(pwd):/zap/wrk/:rw \
          owasp/zap2docker-stable zap-baseline.py \
          -t "${{ env.TARGET_URL }}" \
          -r zap-baseline-report.html \
          -J zap-baseline-report.json \
          -w zap-baseline-report.md \
          --no_fail_on_warn 2>&1 | tee zap-debug.log

        zap_exit_code=${PIPESTATUS[0]}
        echo "ZAP exit code: $zap_exit_code"

        # Check if reports were generated
        echo "Checking for generated reports..."
        ls -la zap-* 2>/dev/null || echo "No zap files found"

        if [ -f "zap-baseline-report.html" ]; then
          echo "‚úÖ DAST scan complete - Reports generated:"
          ls -la zap-baseline-report.*
          echo "HTML report size: $(wc -c < zap-baseline-report.html) bytes"

          # Check if report has content
          if grep -q "ZAP" zap-baseline-report.html; then
            echo "‚úÖ HTML report contains ZAP content"
          else
            echo "‚ö†Ô∏è HTML report may be empty"
          fi
        else
          echo "‚ùå Error: ZAP reports were not generated"
          echo "Debug information:"
          echo "- Target URL: ${{ env.TARGET_URL }}"
          echo "- ZAP exit code: $zap_exit_code"
          echo "- Current directory: $(pwd)"
          echo "- Directory contents:"
          ls -la || echo "Cannot list directory"

          if [ -f "zap-debug.log" ]; then
            echo "ZAP debug output (last 50 lines):"
            tail -50 zap-debug.log
          fi

          echo "Attempting simple ZAP test scan..."
          docker run --rm owasp/zap2docker-stable zap-baseline.py -t "https://httpbin.org" --no_fail_on_warn || echo "Even httpbin scan failed"
        fi
      continue-on-error: true  # Don't fail build on DAST findings (report only)
    
    - name: Upload OWASP ZAP Report
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: zap-dast-report
        path: |
          zap-baseline-report.html
          zap-baseline-report.json
          zap-baseline-report.md
          zap-debug.log
    
    - name: Display DAST Summary
      if: always()
      run: |
        echo ""
        echo "üìä DAST Scan Summary"
        echo "===================="

        echo "Target URL: ${{ env.TARGET_URL }}"

        if [ -f zap-baseline-report.html ]; then
          echo "‚úÖ HTML report generated: zap-baseline-report.html ($(wc -c < zap-baseline-report.html) bytes)"
        else
          echo "‚ùå HTML report not generated"
        fi

        if [ -f zap-baseline-report.json ]; then
          echo "‚úÖ JSON report generated: zap-baseline-report.json ($(wc -c < zap-baseline-report.json) bytes)"
        else
          echo "‚ùå JSON report not generated"
        fi

        if [ -f zap-baseline-report.md ]; then
          echo "‚úÖ Markdown report generated: zap-baseline-report.md ($(wc -c < zap-baseline-report.md) bytes)"
          echo ""
          echo "Report content:"
          echo "=============="
          cat zap-baseline-report.md
        else
          echo "‚ùå Markdown report not generated"
        fi

        if [ -f zap-debug.log ]; then
          echo "‚úÖ Debug log available: zap-debug.log ($(wc -c < zap-debug.log) bytes)"
          echo "Last few lines of debug:"
          echo "======================="
          tail -10 zap-debug.log
        else
          echo "‚ùå Debug log not generated"
        fi
